// Generated by CoffeeScript 1.6.3
(function() {
  var Ball, Canvas, KEY_DOWN, KEY_UP, K_0, K_1, K_2, K_3, K_4, K_5, K_6, K_7, K_8, K_9, K_ALT, K_BACKSPACE, K_CTRL, K_DOWN, K_ENTER, K_ESC, K_LEFT, K_RIGHT, K_SHIFT, K_SPACE, K_TAB, K_UP, K_a, K_b, K_c, K_d, K_e, K_f, K_g, K_h, K_i, K_j, K_k, K_l, K_m, K_n, K_o, K_p, K_q, K_r, K_s, K_t, K_u, K_v, K_w, K_x, K_y, K_z, MOUSE_DOWN, MOUSE_MOTION, MOUSE_UP, MOUSE_WHEEL, Pitch, Player, QUIT, ScoreBoard, Vector2d, WorldModel, clone, gameloop, main, multiply, onkeydown, onmousedown, root;

  K_UP = 38;

  K_DOWN = 40;

  K_RIGHT = 39;

  K_LEFT = 37;

  K_SPACE = 32;

  K_BACKSPACE = 8;

  K_TAB = 9;

  K_ENTER = 13;

  K_SHIFT = 16;

  K_CTRL = 17;

  K_ALT = 18;

  K_ESC = 27;

  K_0 = 48;

  K_1 = 49;

  K_2 = 50;

  K_3 = 51;

  K_4 = 52;

  K_5 = 53;

  K_6 = 54;

  K_7 = 55;

  K_8 = 56;

  K_9 = 57;

  K_a = 65;

  K_b = 66;

  K_c = 67;

  K_d = 68;

  K_e = 69;

  K_f = 70;

  K_g = 71;

  K_h = 72;

  K_i = 73;

  K_j = 74;

  K_k = 75;

  K_l = 76;

  K_m = 77;

  K_n = 78;

  K_o = 79;

  K_p = 80;

  K_q = 81;

  K_r = 82;

  K_s = 83;

  K_t = 84;

  K_u = 85;

  K_v = 86;

  K_w = 87;

  K_x = 88;

  K_y = 89;

  K_z = 90;

  QUIT = 0;

  KEY_DOWN = 1;

  KEY_UP = 2;

  MOUSE_MOTION = 3;

  MOUSE_UP = 4;

  MOUSE_DOWN = 5;

  MOUSE_WHEEL = 6;

  onkeydown = function(ev, wm) {
    switch (ev.keyCode) {
      case K_k:
        return wm.pitch.kickoff();
      case K_r:
        return wm.reset();
    }
  };

  onmousedown = function(ev, wm, x, y) {
    return 0;
  };

  Player = (function() {
    function Player(p, dir, wm, side) {
      this.fc = 'grey';
      this.sc = 'black';
      this.m = 5.0;
      this.r = 8;
      this.t = 'none';
      this.v = [0, 0];
      this.decay = 0.4;
      this.maxdashforce = 6;
      this.maxkickforce = 2.0;
      this.maxturnangle = 0.1;
      this.force = 0;
      this.kickforce = 0;
      this.dd = 0;
      this.wm = wm;
      this.side = side;
      this.p = this.transpos(p);
      this.d = this.transdir(dir);
      this.initpos = clone(this.p);
    }

    Player.prototype.reset = function() {
      return this.p = clone(this.initpos);
    };

    Player.prototype.render = function(canvas) {
      var fill_color, stroke_color, x, y;
      if (!this.client || !this.client.fill_color) {
        fill_color = this.fc;
      } else {
        fill_color = this.client.fill_color;
      }
      stroke_color = this.sc;
      x = this.p[0];
      y = this.p[1];
      canvas.fillCircle(fill_color, x, y, this.r);
      canvas.drawCircle(stroke_color, x, y, this.r);
      return canvas.fillArc(stroke_color, x, y, this.r, this.d - 2 * Math.PI / 5, this.d + 2 * Math.PI / 5);
    };

    Player.prototype.take_action = function() {
      var action, actions, _results;
      if (!this.client) {
        return;
      }
      actions = this.client.think(this.getbasicinfo());
      _results = [];
      for (action in actions) {
        switch (action) {
          case 'jump':
            _results.push(this.jump(actions['jump']));
            break;
          case 'dash':
            _results.push(this.dash(actions['dash']));
            break;
          case 'turn':
            _results.push(this.turn(actions['turn']));
            break;
          case 'kick':
            _results.push(this.kick(actions['kick']));
            break;
          case 'suck':
            _results.push(this.suck());
            break;
          default:
            _results.push(void 0);
        }
      }
      return _results;
    };

    Player.prototype.update = function() {
      var a, ds, dv, unitv;
      if (this.wm.selected !== this) {
        this.take_action();
      }
      if (Vector2d.len(this.v) > 1e-5) {
        ds = this.v;
        this.p = Vector2d.add(this.p, ds);
        this.v = Vector2d.multiply(this.v, this.decay);
      }
      a = this.force / this.m;
      this.force = 0;
      unitv = Vector2d.vector(this.d);
      dv = Vector2d.multiply(unitv, a);
      this.v = Vector2d.add(this.v, dv);
      this.d += this.dd;
      this.dd = 0;
      if (this.kickforce !== 0) {
        this.wm.pitch.last_touch_ball = this.side;
      }
      this.wm.ball.acc(unitv, this.kickforce);
      return this.kickforce = 0;
    };

    Player.prototype.dash = function(force) {
      if (force > this.maxdashforce) {
        force = this.maxdashforce;
      }
      if (force < -this.maxdashforce) {
        force = -this.maxdashforce;
      }
      return this.force = force;
    };

    Player.prototype.turn = function(dir) {
      this.dd = dir;
      if (this.dd > this.maxturnangle) {
        this.dd = this.maxturnangle;
      }
      if (this.dd < -this.maxturnangle) {
        return this.dd = -this.maxturnangle;
      }
    };

    Player.prototype.kick = function(force) {
      var bp, p2b, unitv;
      if (!this.wm) {
        return;
      }
      if (force <= 0) {
        return;
      }
      bp = this.wm.ball.p;
      if (Vector2d.distance(this.p, bp) > this.r + this.wm.ball.r + 3) {
        return;
      }
      p2b = Vector2d.subtract(bp, this.p);
      unitv = Vector2d.vector(this.d);
      if (Math.abs(Vector2d.angle(p2b, unitv)) > Math.PI / 6) {
        return;
      }
      if (force > this.maxkickforce) {
        force = this.maxkickforce;
      }
      return this.kickforce = force;
    };

    Player.prototype.jump = function(pos) {
      this.p = clone(pos);
      return this.p = this.transpos(this.p);
    };

    Player.prototype.suck = function() {
      var bp, p2b, pos, unitdir, unitv;
      pos = this.transpos(this.wm.ball.p);
      if (this.client.teamnum !== 0) {
        return;
      }
      if (pos[0] > -this.wm.pitch.pitch_length / 2 + this.wm.pitch.penalty_area_length) {
        return;
      }
      if (pos[1] > this.wm.pitch.penalty_area_width / 2) {
        return;
      }
      bp = this.wm.ball.p;
      if (Vector2d.distance(this.p, bp) > this.r + this.wm.ball.r + 3) {
        return;
      }
      p2b = Vector2d.subtract(bp, this.p);
      unitv = Vector2d.vector(this.d);
      if (Math.abs(Vector2d.angle(p2b, unitv)) > Math.PI / 6) {
        return;
      }
      unitdir = Vector2d.vector(this.d);
      this.wm.ball.p = Vector2d.add(Vector2d.multiply(unitdir, this.wm.ball.r + this.r + 0.1), this.p);
      this.wm.ball.v = [0, 0];
      return this.wm.pitch.change_state('goalkick_' + this.side);
    };

    Player.prototype.getbasicinfo = function() {
      var p, player, wm, _i, _j, _len, _len1, _ref, _ref1;
      wm = {};
      wm.leftplayers = [];
      wm.rightplayers = [];
      _ref = this.wm.leftplayers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        p = clone(player.p);
        p = this.transpos(p);
        wm.leftplayers.push(p);
      }
      _ref1 = this.wm.rightplayers;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        player = _ref1[_j];
        p = clone(player.p);
        p = this.transpos(p);
        wm.rightplayers.push(p);
      }
      wm.gamestate = this.wm.pitch.state;
      wm.ball = clone(this.wm.ball.p);
      wm.ball = this.transpos(wm.ball);
      wm.mydir = this.transdir(this.d);
      return wm;
    };

    Player.prototype.transpos = function(p) {
      if (this.side === 'left') {
        return p;
      }
      return [-p[0], -p[1]];
    };

    Player.prototype.transdir = function(dir) {
      if (this.side === 'left') {
        return dir;
      }
      return Math.normaliseRadians(dir + Math.PI);
    };

    return Player;

  })();

  ScoreBoard = (function() {
    function ScoreBoard() {
      this.board_length = 400;
      this.board_height = 50;
      this.left_score = 0;
      this.right_score = 0;
      this.left_teamname = "???";
      this.right_teamname = "???";
      this.board_color = '#000';
      this.text_color = '#FFF';
      this.timer = 0;
    }

    ScoreBoard.prototype.render = function(canvas) {
      var board, board_text;
      if (this.state === 'playon') {
        this.timer += 1;
      }
      board = {
        x: -this.board_length / 2,
        y: -canvas.h / 2,
        w: this.board_length,
        h: this.board_height
      };
      canvas.fillRect(this.board_color, board);
      board_text = this.left_teamname + '   ' + this.left_score + ' : ';
      board_text += this.right_score + '   ' + this.right_teamname;
      canvas.drawText(this.text_color, '20px play', board_text, 0, -canvas.h / 2 + 20);
      return canvas.drawText(this.text_color, '20px play', this.state + '  ' + parseInt(this.timer / 10), 0, -canvas.h / 2 + 40);
    };

    ScoreBoard.prototype.reset = function() {
      this.timer = 0;
      this.left_score = 0;
      return this.right_score = 0;
    };

    ScoreBoard.prototype.set_state = function(st) {
      return this.state = st;
    };

    ScoreBoard.prototype.increase_left_score = function() {
      return this.left_score += 1;
    };

    ScoreBoard.prototype.increase_right_score = function() {
      return this.right_score += 1;
    };

    ScoreBoard.prototype.switch_sides = function() {
      var _ref, _ref1;
      _ref = [this.right_score, this.left_score], this.left_score = _ref[0], this.right_score = _ref[1];
      return _ref1 = [this.right_teamname, this.left_teamname], this.left_teamname = _ref1[0], this.right_teamname = _ref1[1], _ref1;
    };

    return ScoreBoard;

  })();

  Pitch = (function() {
    function Pitch() {
      this.pitch_length = 1050;
      this.pitch_width = 680;
      this.center_circle_r = 91.5;
      this.freekick_circle_r = 91.5;
      this.penalty_area_length = 165;
      this.penalty_area_width = 403.2;
      this.penalty_circle_r = 91.5;
      this.penalty_spot_dist = 110;
      this.goal_width = 140.2;
      this.goal_area_length = 55;
      this.goal_area_width = 183.2;
      this.goal_depth = 24.4;
      this.goal_post_radius = 0.6;
      this.corner_arc_r = 10;
      this.half_time = 10000;
      this.goal_pillars = {
        left: {
          up: [-(this.pitch_length / 2), this.goal_width / 2],
          bottom: [-(this.pitch_length / 2), -(this.goal_width / 2)]
        },
        right: {
          up: [this.pitch_length / 2, this.goal_width / 2],
          bottom: [this.pitch_length / 2, -(this.goal_width / 2)]
        }
      };
      this.field_color = 'RGB(31, 160, 31)';
      this.line_color = 'RGB(255, 255, 255)';
      this.goal_color = '#000';
      this.state = "before_kickoff";
      this.last_goal_side = null;
      this.auto_kickoff = false;
      this.kickoff_delay = 0;
      this.second_half = false;
    }

    Pitch.prototype.checkrules = function(wm) {
      this.wm = wm;
      switch (this.state) {
        case 'before_kickoff':
          return this.before_kickoff_rules();
        case 'kickoff_left':
          return this.kickoff_left_rules();
        case 'kickoff_right':
          return this.kickoff_right_rules();
        case 'playon':
          return this.playon_rules();
        case 'goalkick_left':
          return this.goalkick_left_rules();
        case 'goalkick_right':
          return this.goalkick_right_rules();
        case 'kickin_left':
          return this.kickin_left_rules();
        case 'kickin_right':
          return this.kickin_right_rules();
        case 'cornerkick_left':
          return this.cornerkick_left_rules();
        case 'cornerkick_right':
          return this.cornerkick_right_rules();
      }
    };

    Pitch.prototype.render = function(canvas) {
      var field, goal_area_bottom_y, goal_area_top_y, goal_area_x, goal_area_y_abs, goal_top_y, half_length, left_goal, left_x, pen_bottom_y, pen_circle_dia, pen_circle_r, pen_circle_y_degree_abs, pen_spot_x, pen_top_y, pen_x, post_bottom_y, post_diameter, post_top_y, right_goal, right_x;
      field = {
        x: -canvas.w / 2,
        y: -canvas.h / 2,
        w: canvas.w,
        h: canvas.h
      };
      canvas.fillRect(this.field_color, field);
      field = {
        x: -this.pitch_length / 2,
        y: -this.pitch_width / 2,
        w: this.pitch_length,
        h: this.pitch_width
      };
      canvas.drawRect(this.line_color, field);
      canvas.drawLine(this.line_color, 0, field.y, 0, field.y + field.h);
      canvas.drawArc(this.line_color, 0, 0, this.center_circle_r, 0, 2 * Math.PI);
      canvas.drawArc(this.line_color, field.x, field.y, this.corner_arc_r, 0, Math.PI / 2);
      canvas.drawArc(this.line_color, field.x + field.w, field.y, this.corner_arc_r, Math.PI / 2, Math.PI);
      canvas.drawArc(this.line_color, field.x + field.w, field.y + field.h, this.corner_arc_r, Math.PI, 3 * Math.PI / 2);
      canvas.drawArc(this.line_color, field.x, field.y + field.h, this.corner_arc_r, 3 * Math.PI / 2, 2 * Math.PI);
      half_length = this.pitch_length / 2;
      left_x = -half_length;
      right_x = half_length;
      pen_top_y = -this.penalty_area_width / 2;
      pen_bottom_y = this.penalty_area_width / 2;
      pen_circle_y_degree_abs = Math.acos((this.penalty_area_length - this.penalty_spot_dist) / this.penalty_circle_r);
      pen_circle_r = this.penalty_circle_r;
      pen_circle_dia = this.penalty_circle_r * 2.0;
      pen_x = -(half_length - this.penalty_area_length);
      pen_spot_x = -(half_length - this.penalty_spot_dist);
      canvas.drawArc(this.line_color, -(half_length + this.penalty_spot_dist - this.penalty_area_length), 0, pen_circle_dia, -pen_circle_y_degree_abs, pen_circle_y_degree_abs);
      canvas.drawLine(this.line_color, left_x, pen_top_y, pen_x, pen_top_y);
      canvas.drawLine(this.line_color, pen_x, pen_top_y, pen_x, pen_bottom_y);
      canvas.drawLine(this.line_color, pen_x, pen_bottom_y, left_x, pen_bottom_y);
      canvas.drawArc(this.line_color, pen_spot_x, 0, 1, 0, 2 * Math.PI);
      pen_x = +(half_length - this.penalty_area_length);
      pen_spot_x = +(half_length - this.penalty_spot_dist);
      canvas.drawArc(this.line_color, +(half_length + this.penalty_spot_dist - this.penalty_area_length), 0, pen_circle_dia, Math.PI - pen_circle_y_degree_abs, Math.PI + pen_circle_y_degree_abs);
      canvas.drawLine(this.line_color, right_x, pen_top_y, pen_x, pen_top_y);
      canvas.drawLine(this.line_color, pen_x, pen_top_y, pen_x, pen_bottom_y);
      canvas.drawLine(this.line_color, pen_x, pen_bottom_y, right_x, pen_bottom_y);
      canvas.drawArc(this.line_color, pen_spot_x, 0, 1, 0, 2 * Math.PI);
      left_x = -this.pitch_length / 2;
      right_x = +this.pitch_length / 2;
      goal_area_y_abs = this.goal_area_width / 2;
      goal_area_top_y = -goal_area_y_abs;
      goal_area_bottom_y = +goal_area_y_abs;
      goal_area_x = left_x + this.goal_area_length;
      canvas.drawLine(this.line_color, left_x, goal_area_top_y, goal_area_x, goal_area_top_y);
      canvas.drawLine(this.line_color, goal_area_x, goal_area_top_y, goal_area_x, goal_area_bottom_y);
      canvas.drawLine(this.line_color, goal_area_x, goal_area_bottom_y, left_x, goal_area_bottom_y);
      goal_area_x = right_x - this.goal_area_length;
      canvas.drawLine(this.line_color, right_x, goal_area_top_y, goal_area_x, goal_area_top_y);
      canvas.drawLine(this.line_color, goal_area_x, goal_area_top_y, goal_area_x, goal_area_bottom_y);
      canvas.drawLine(this.line_color, goal_area_x, goal_area_bottom_y, right_x, goal_area_bottom_y);
      goal_top_y = -this.goal_width * 0.5;
      post_top_y = -this.goal_width * 0.5 - this.goal_post_radius * 2.0;
      post_bottom_y = this.goal_width * 0.5;
      post_diameter = this.goal_post_radius * 2.0;
      left_goal = {
        x: -this.pitch_length / 2 - this.goal_depth - 1,
        y: goal_top_y,
        w: this.goal_depth,
        h: this.goal_width
      };
      canvas.fillRect(this.goal_color, left_goal);
      right_goal = {
        x: this.pitch_length / 2 + 1,
        y: goal_top_y,
        w: this.goal_depth,
        h: this.goal_width
      };
      canvas.fillRect(this.goal_color, right_goal);
      this.board.set_state(this.state);
      return this.board.render(canvas);
    };

    Pitch.prototype.goalkick_left_rules = function() {
      var player, _i, _len, _ref;
      _ref = this.wm.rightplayers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        if (this.in_left_penalty(player.p)) {
          player.p[0] = -this.pitch_length / 2 + this.penalty_area_length + this.freekick_circle_r;
        }
      }
      if (!this.in_left_penalty(this.wm.ball.p)) {
        return this.change_state('playon');
      }
    };

    Pitch.prototype.goalkick_right_rules = function() {
      var player, _i, _len, _ref;
      _ref = this.wm.leftplayers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        if (this.in_right_penalty(player.p)) {
          player.p[0] = this.pitch_length / 2 - this.penalty_area_length - this.freekick_circle_r;
        }
      }
      if (!this.in_right_penalty(this.wm.ball.p)) {
        return this.change_state('playon');
      }
    };

    Pitch.prototype.kickin_left_rules = function() {
      return this.freekick_left_rules();
    };

    Pitch.prototype.kickin_right_rules = function() {
      return this.freekick_right_rules();
    };

    Pitch.prototype.cornerkick_left_rules = function() {
      return this.freekick_left_rules();
    };

    Pitch.prototype.cornerkick_right_rules = function() {
      return this.freekick_right_rules();
    };

    Pitch.prototype.freekick_left_rules = function() {
      var player, _i, _len, _ref;
      _ref = this.wm.rightplayers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        this.freekick_circle(player, this.wm.ball.p);
      }
      if (this.last_touch_ball) {
        return this.change_state('playon');
      }
    };

    Pitch.prototype.freekick_right_rules = function() {
      var player, _i, _len, _ref;
      _ref = this.wm.leftplayers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        this.freekick_circle(player, this.wm.ball.p);
      }
      if (this.last_touch_ball) {
        return this.change_state('playon');
      }
    };

    Pitch.prototype.freekick_circle = function(player, ball) {
      var ball2player, d, pp;
      pp = player.p;
      d = 2 * this.freekick_circle_r;
      if (Vector2d.distance(pp, ball) < this.freekick_circle_r) {
        ball2player = Vector2d.unit(Vector2d.subtract(pp, ball));
        player.p = Vector2d.add(Vector2d.multiply(ball2player, this.freekick_circle_r), ball);
        if (player.p[0] > this.pitch_length / 2) {
          player.p[0] -= d;
        }
        if (player.p[0] < -this.pitch_length / 2) {
          player.p[0] += d;
        }
        if (player.p[1] > this.pitch_width / 2) {
          player.p[1] -= d;
        }
        if (player.p[1] < -this.pitch_width / 2) {
          return player.p[1] += d;
        }
      }
    };

    Pitch.prototype.before_kickoff_rules = function() {
      var player, _i, _j, _len, _len1, _ref, _ref1;
      _ref = this.wm.leftplayers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        if (player.p[0] > -player.r) {
          player.p[0] = -player.r;
        }
        if (Vector2d.distance(player.p, [0, 0]) < this.center_circle_r) {
          player.p[0] = -this.center_circle_r;
        }
      }
      _ref1 = this.wm.rightplayers;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        player = _ref1[_j];
        if (player.p[0] < player.r) {
          player.p[0] = player.r;
        }
        if (Vector2d.distance(player.p, [0, 0]) < this.center_circle_r) {
          player.p[0] = this.center_circle_r;
        }
      }
      if (this.auto_kickoff) {
        this.kickoff_delay -= 1;
        if (this.kickoff_delay <= 0) {
          return this.kickoff();
        }
      }
    };

    Pitch.prototype.kickoff = function() {
      switch (this.state) {
        case 'before_kickoff':
          if (this.last_goal_side === 'left') {
            return this.change_state('kickoff_right');
          } else {
            return this.change_state('kickoff_left');
          }
      }
    };

    Pitch.prototype.kickoff_left_rules = function() {
      var player, _i, _len, _ref;
      _ref = this.wm.rightplayers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        if (player.p[0] < player.r) {
          player.p[0] = player.r;
        }
        if (Vector2d.distance(player.p, [0, 0]) < this.center_circle_r) {
          player.p[0] = this.center_circle_r;
        }
      }
      if (this.last_touch_ball) {
        return this.change_state('playon');
      }
    };

    Pitch.prototype.kickoff_right_rules = function() {
      var player, _i, _len, _ref;
      _ref = this.wm.leftplayers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        if (player.p[0] > -player.r) {
          player.p[0] = -player.r;
        }
        if (Vector2d.distance(player.p, [0, 0]) < this.center_circle_r) {
          player.p[0] = -this.center_circle_r;
        }
      }
      if (this.last_touch_ball) {
        return this.change_state('playon');
      }
    };

    Pitch.prototype.playon_rules = function() {
      var x, y;
      x = this.wm.ball.p[0];
      y = this.wm.ball.p[1];
      if (Math.abs(y) < this.goal_width / 2) {
        if (x < -this.pitch_length / 2 - this.wm.ball.r) {
          if (this.is_goal(this.wm.ball, this.goal_pillars.left.bottom, this.goal_pillars.left.up)) {
            this.board.increase_right_score();
            this.last_goal_side = 'right';
            this.change_state('before_kickoff');
            this.wm.ball.reset();
            return;
          }
        }
        if (x > this.pitch_length / 2 + this.wm.ball.r) {
          if (this.is_goal(this.wm.ball, this.goal_pillars.right.bottom, this.goal_pillars.right.up)) {
            this.board.increase_left_score();
            this.last_goal_side = 'left';
            this.change_state('before_kickoff');
            this.wm.ball.reset();
            return;
          }
        }
      } else {
        if (Math.abs(y) > this.pitch_width / 2 + this.wm.ball.r) {
          if (y > 0) {
            y = this.pitch_width / 2;
          } else {
            y = -this.pitch_width / 2;
          }
          x = this.wm.ball.last_pos[0];
          this.wm.ball.reset();
          this.wm.ball.p = [x, y];
          if (this.last_touch_ball === 'left') {
            this.change_state('kickin_right');
          } else {
            this.change_state('kickin_left');
          }
          return;
        }
      }
      if (x < -this.pitch_length / 2 - this.wm.ball.r) {
        if (this.last_touch_ball === 'right') {
          this.wm.ball.reset();
          this.wm.ball.p = [-this.pitch_length / 2 + this.penalty_spot_dist, 0];
          this.change_state('goalkick_left');
        } else {
          this.wm.ball.reset();
          this.wm.ball.p = [-this.pitch_length / 2, Math.sign(y) * this.pitch_width / 2];
          this.change_state('cornerkick_right');
        }
        return;
      }
      if (x > this.pitch_length / 2 + this.wm.ball.r) {
        if (this.last_touch_ball === 'left') {
          this.wm.ball.reset();
          this.wm.ball.p = [this.pitch_length / 2 - this.penalty_spot_dist, 0];
          this.change_state('goalkick_right');
        } else {
          this.wm.ball.reset();
          this.wm.ball.p = [this.pitch_length / 2, Math.sign(y) * this.pitch_width / 2];
          this.change_state('cornerkick_left');
        }
        return;
      }
      if (this.board.timer > this.half_time && !this.second_half) {
        this.second_half = true;
        this.change_state('before_kickoff');
        this.wm.ball.reset();
        this.auto_kickoff = true;
        this.kickoff_delay = 50;
        this.wm.switch_sides();
        this.board.switch_sides();
        this.last_goal_side = null;
      }
      if (this.board.timer > 2 * this.half_time) {
        return this.change_state('game_over');
      }
    };

    Pitch.prototype.is_goal = function(ball, l1, l2) {
      var denominator, u1, u2, v1, v2, x, x1, x2, y, y1, y2;
      x1 = ball.last_pos[0];
      y1 = ball.last_pos[1];
      x2 = ball.p[0];
      y2 = ball.p[1];
      u1 = l1[0];
      v1 = l1[1];
      u2 = l2[0];
      v2 = l2[1];
      denominator = (y2 - y1) * (u2 - u1) - (x1 - x2) * (v1 - v2);
      if (denominator === 0) {
        return false;
      }
      x = ((x2 - x1) * (u2 - u1) * (v1 - y1) + (y2 - y1) * (u2 - u1) * x1 - (v2 - v1) * (x2 - x1) * u1) / denominator;
      y = ((y2 - y1) * (v2 - v1) * (u1 - x1) + (x2 - x1) * (v2 - v1) * y1 - (u2 - u1) * (y2 - y1) * v1) / denominator;
      if ((x - u1) * (x - u2) <= 0 && (y - v1) * (y - v2) <= 0) {
        this.auto_kickoff = true;
        this.kickoff_delay = 50;
        return true;
      }
      return false;
    };

    Pitch.prototype.reset = function() {
      this.change_state('before_kickoff');
      this.auto_kickoff = true;
      this.kickoff_delay = 100;
      this.second_half = false;
      return this.last_goal_side = null;
    };

    Pitch.prototype.change_state = function(state) {
      this.state = state;
      if (this.state !== 'playon') {
        return this.last_touch_ball = null;
      }
    };

    Pitch.prototype.in_left_penalty = function(pos) {
      return pos[0] <= -this.pitch_length / 2 + this.penalty_area_length && Math.abs(pos[1]) <= this.penalty_area_width / 2;
    };

    Pitch.prototype.in_right_penalty = function(pos) {
      return pos[0] >= this.pitch_length / 2 - this.penalty_area_length && Math.abs(pos[1]) <= this.penalty_area_width / 2;
    };

    return Pitch;

  })();

  Ball = (function() {
    function Ball(x, y) {
      this.r = 2.5;
      this.m = 0.2;
      this.sc = "#FFA500";
      this.fc = "#FFA500";
      this.p = [x, y];
      this.v = [0, 0];
      this.decay = 0.94;
      this.last_pos = this.p;
    }

    Ball.prototype.acc = function(dir, force) {
      var a, dv, unitdir;
      unitdir = Vector2d.unit(dir);
      a = Vector2d.multiply(unitdir, force / this.m);
      dv = a;
      return this.v = Vector2d.add(this.v, dv);
    };

    Ball.prototype.render = function(canvas) {
      var x, y;
      x = this.p[0];
      y = this.p[1];
      canvas.drawCircle(this.sc, x, y, this.r + 1);
      return canvas.fillCircle(this.fc, x, y, this.r);
    };

    Ball.prototype.update = function() {
      var ds;
      this.last_pos = this.p;
      if (Vector2d.len(this.v) > 1e-3) {
        ds = this.v;
        this.p = Vector2d.add(this.p, ds);
        return this.v = Vector2d.multiply(this.v, this.decay);
      }
    };

    Ball.prototype.reset = function() {
      this.p = [0, 0];
      return this.v = [0, 0];
    };

    return Ball;

  })();

  Canvas = function(ctx, w, h) {
    this.ctx = ctx;
    this.w = w;
    return this.h = h;
  };

  Canvas.prototype.fillRect = function(color, rect) {
    this.ctx.fillStyle = color;
    return this.ctx.fillRect(this.xscreen(rect.x), this.yscreen(rect.y), rect.w, rect.h);
  };

  Canvas.prototype.drawRect = function(color, rect) {
    this.ctx.strokeStyle = color;
    return this.ctx.strokeRect(this.xscreen(rect.x), this.yscreen(rect.y), rect.w, rect.h);
  };

  Canvas.prototype.drawLine = function(color, sx, sy, ex, ey) {
    this.ctx.strokeStyle = color;
    this.ctx.beginPath();
    this.ctx.moveTo(this.xscreen(sx), this.yscreen(sy));
    this.ctx.lineTo(this.xscreen(ex), this.yscreen(ey));
    return this.ctx.stroke();
  };

  Canvas.prototype.drawArc = function(color, x, y, r, sAngle, eAngle) {
    this.ctx.strokeStyle = color;
    this.ctx.beginPath();
    this.ctx.arc(this.xscreen(x), this.yscreen(y), r, sAngle, eAngle);
    return this.ctx.stroke();
  };

  Canvas.prototype.fillArc = function(color, x, y, r, sAngle, eAngle) {
    this.ctx.fillStyle = color;
    this.ctx.beginPath();
    this.ctx.arc(this.xscreen(x), this.yscreen(y), r, sAngle, eAngle);
    return this.ctx.fill();
  };

  Canvas.prototype.drawCircle = function(color, x, y, r) {
    return this.drawArc(color, x, y, r, 0, 2 * Math.PI);
  };

  Canvas.prototype.fillCircle = function(color, x, y, r) {
    return this.fillArc(color, x, y, r, 0, 2 * Math.PI);
  };

  Canvas.prototype.drawText = function(color, font, text, x, y) {
    this.ctx.fillStyle = color;
    this.ctx.font = font;
    x = x - this.ctx.measureText(text).width / 2;
    return this.ctx.fillText(text, this.xscreen(x), this.yscreen(y));
  };

  Canvas.prototype.xscreen = function(x) {
    return x + this.w / 2;
  };

  Canvas.prototype.yscreen = function(y) {
    return y + this.h / 2;
  };

  WorldModel = (function() {
    function WorldModel() {
      this.objs = [];
      this.leftplayers = [];
      this.rightplayers = [];
    }

    WorldModel.prototype.register = function(obj) {
      return this.objs.push(obj);
    };

    WorldModel.prototype.unregister = function(obj) {
      var idx;
      idx = this.objs.indexOf(obj);
      if (idx >= 0) {
        return this.objs.splice(idx, 1);
      }
    };

    WorldModel.prototype.render = function(canvas) {
      var obj, _i, _len, _ref, _results;
      _ref = this.objs;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        if (obj.render) {
          _results.push(obj.render(canvas));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    WorldModel.prototype.update = function() {
      var i, j, obj, wm, _i, _j, _len, _ref, _ref1, _results;
      _ref = this.objs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        if (obj.update) {
          obj.update();
        }
      }
      wm = {
        leftplayers: this.leftplayers,
        rightplayers: this.rightplayers,
        ball: this.ball
      };
      this.pitch.checkrules(this);
      _results = [];
      for (i = _j = 0, _ref1 = this.objs.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        _results.push((function() {
          var _k, _ref2, _ref3, _results1;
          _results1 = [];
          for (j = _k = _ref2 = i + 1, _ref3 = this.objs.length; _ref2 <= _ref3 ? _k < _ref3 : _k > _ref3; j = _ref2 <= _ref3 ? ++_k : --_k) {
            _results1.push(this.collide(this.objs[i], this.objs[j]));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    WorldModel.prototype.reset = function() {
      var obj, _i, _len, _ref, _results;
      _ref = this.objs;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        if (obj.reset) {
          _results.push(obj.reset());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    WorldModel.prototype.switch_sides = function() {
      var i, left_player, right_player, _i, _len, _ref, _ref1, _ref2, _results;
      i = 0;
      _ref = this.leftplayers;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        left_player = _ref[_i];
        right_player = this.rightplayers[i];
        _ref1 = [right_player.client, left_player.client], left_player.client = _ref1[0], right_player.client = _ref1[1];
        _ref2 = [right_player.sc, left_player.sc], left_player.sc = _ref2[0], right_player.sc = _ref2[1];
        left_player.client.side = 'left';
        right_player.client.side = 'right';
        _results.push(i += 1);
      }
      return _results;
    };

    WorldModel.prototype.collide = function(x, y) {
      var dis, m1, m2, normal, overlap, tangent, v1, v1a, v1b, v1c, v2, v2a, v2b, v2c;
      if (!x.r) {
        return;
      }
      if (!y.r) {
        return;
      }
      dis = Vector2d.distance(x.p, y.p);
      if (dis > x.r + y.r) {
        return;
      }
      if (x.r > y.r && x.side) {
        this.pitch.last_touch_ball = x.side;
      }
      if (x.r < y.r && y.side) {
        this.pitch.last_touch_ball = y.side;
      }
      m1 = x.m;
      m2 = y.m;
      v1 = x.v;
      v2 = y.v;
      normal = Vector2d.unit(Vector2d.subtract(x.p, y.p));
      tangent = [-normal[1], normal[0]];
      v1a = Vector2d.dot(v1, normal);
      v1b = Vector2d.dot(v1, tangent);
      v2a = Vector2d.dot(v2, normal);
      v2b = Vector2d.dot(v2, tangent);
      v2c = (m1 * 0.2 * (v1a - v2a) + m1 * v1a + m2 * v2a) / (m2 + m1);
      v1c = (m1 * v1a + m2 * v2a - m2 * v2c) / m1;
      x.v[0] = v1c * normal[0] + v1b * tangent[0];
      x.v[1] = v1c * normal[1] + v1b * tangent[1];
      y.v[0] = v2c * normal[0] + v2b * tangent[0];
      y.v[1] = v2c * normal[1] + v2b * tangent[1];
      overlap = dis - x.r - y.r;
      x.p = Vector2d.add(x.p, Vector2d.multiply(normal, -overlap * x.r / (x.r + y.r)));
      return y.p = Vector2d.add(y.p, Vector2d.multiply(normal, overlap * y.r / (x.r + y.r)));
    };

    return WorldModel;

  })();

  Vector2d = {};

  Vector2d.distance = function(a, b) {
    return Vector2d.len(Vector2d.subtract(a, b));
  };

  Vector2d.subtract = function(a, b) {
    return [a[0] - b[0], a[1] - b[1]];
  };

  Vector2d.add = function(a, b) {
    return [a[0] + b[0], a[1] + b[1]];
  };

  Vector2d.multiply = multiply = function(a, s) {
    if (typeof s === 'number') {
      return [a[0] * s, a[1] * s];
    }
    return [a[0] * s[0], a[1] * s[1]];
  };

  Vector2d.divide = function(a, s) {
    if (typeof s === 'number') {
      return [a[0] / s, a[1] / s];
    }
    throw new Error('only divide by scalar supported');
  };

  Vector2d.len = function(v) {
    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  };

  Vector2d.unit = function(v) {
    var len;
    len = Vector2d.len(v);
    if (len) {
      return [v[0] / len, v[1] / len];
    }
    return [0, 0];
  };

  Vector2d.rotate = function(v, angle) {
    angle = math.normaliseRadians(angle);
    return [v[0] * Math.cos(angle) - v[1] * Math.sin(angle), v[0] * Math.sin(angle) + v[1] * Math.cos(angle)];
  };

  Vector2d.dot = function(v1, v2) {
    return (v1[0] * v2[0]) + (v1[1] * v2[1]);
  };

  Vector2d.angle = function(v1, v2) {
    var perpDot;
    perpDot = v1[0] * v2[1] - v1[1] * v2[0];
    return Math.atan2(perpDot, Vector2d.dot(v1, v2));
  };

  Vector2d.truncate = function(v, maxLength) {
    if (Vector2d.len(v) > maxLength) {
      return multiply(Vector2d.unit(v), maxLength);
    }
    return v;
  };

  Vector2d.vector = function(angle) {
    return [Math.cos(angle), Math.sin(angle)];
  };

  Math.normaliseDegrees = function(degrees) {
    degrees = degrees % 360;
    if (degrees < 0) {
      degrees += 360;
    }
    return degrees;
  };

  Math.normaliseRadians = function(radians) {
    radians = radians % (2 * Math.PI);
    if (radians < -Math.PI) {
      radians += 2 * Math.PI;
    }
    if (radians > Math.PI) {
      radians -= 2 * Math.PI;
    }
    return radians;
  };

  Math.degrees = function(radians) {
    return radians * (180 / Math.PI);
  };

  Math.radians = function(degrees) {
    return degrees * (Math.PI / 180);
  };

  Math.sign = function(number) {
    return number / Math.abs(number);
  };

  main = function() {
    var ball, board, c, canvas, ctx, height, i, left_select, offsetX, offsetY, option, pitch, player, playernum, ratio, ratioh, ratiow, right_select, start_button, start_game, teamname, width, world, _i;
    width = 1280.0;
    height = 800.0;
    playernum = 11;
    c = document.getElementById("myCanvas");
    ctx = c.getContext("2d");
    c.width = window.innerWidth;
    c.height = window.innerHeight;
    ratiow = c.width / width;
    ratioh = c.height / height;
    if (ratiow < ratioh) {
      ratio = ratiow;
      c.height = height * ratio;
    } else {
      ratio = ratioh;
      c.width = width * ratio;
    }
    ctx.scale(ratio, ratio);
    offsetX = c.offsetLeft;
    offsetY = c.offsetTop;
    canvas = new Canvas(ctx, width, height);
    world = new WorldModel();
    pitch = new Pitch();
    world.register(pitch);
    world.pitch = pitch;
    board = new ScoreBoard();
    world.register(board);
    pitch.board = board;
    ball = new Ball(0, 0);
    world.register(ball);
    world.ball = ball;
    for (i = _i = 0; 0 <= playernum ? _i < playernum : _i > playernum; i = 0 <= playernum ? ++_i : --_i) {
      player = new Player([-500 + i * 30, 360], 0, world, 'left');
      world.register(player);
      world.leftplayers.push(player);
      player = new Player([-500 + i * 30, -360], 0, world, 'right');
      world.register(player);
      world.rightplayers.push(player);
    }
    start_game = function() {
      var guest_color, host_color, left, right, _j, _k, _len, _len1, _ref, _ref1;
      host_color = 'black';
      guest_color = 'blue';
      left = left_select.options[left_select.selectedIndex].text;
      right = right_select.options[right_select.selectedIndex].text;
      pitch.board.left_teamname = left;
      pitch.board.right_teamname = right;
      i = 0;
      _ref = world.leftplayers;
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        player = _ref[_j];
        eval('player.client = new client1.' + left + '(i, \'left\')');
        player.sc = host_color;
        i += 1;
      }
      i = 0;
      _ref1 = world.rightplayers;
      for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
        player = _ref1[_k];
        eval('player.client = new client2.' + right + '(i, \'right\')');
        player.sc = guest_color;
        i += 1;
      }
      return world.reset();
    };
    setInterval(function() {
      return gameloop(world, canvas);
    }, 20);
    left_select = document.getElementById("left-select");
    right_select = document.getElementById("right-select");
    start_button = document.getElementById("start");
    for (teamname in client1) {
      option = document.createElement('option');
      option.text = teamname;
      left_select.add(option, null);
    }
    for (teamname in client2) {
      option = document.createElement('option');
      option.text = teamname;
      right_select.add(option, null);
    }
    start_button.addEventListener('click', start_game);
    document.addEventListener('mousedown', function(ev) {
      var x, y;
      if (ev.offsetX === void 0) {
        x = ev.pageX - offsetX - width / 2;
        y = ev.pageY - offsetY - height / 2;
      } else {
        x = ev.offsetX - width / 2;
        y = ev.offsetY - height / 2;
      }
      return onmousedown(ev, world, x, y);
    }, false);
    document.addEventListener('keydown', function(ev) {
      return onkeydown(ev, world);
    }, false);
    return window.onresize = function() {
      c.width = window.innerWidth;
      c.height = window.innerHeight;
      ratiow = c.width / width;
      ratioh = c.height / height;
      if (ratiow < ratioh) {
        ratio = ratiow;
        c.height = height * ratio;
      } else {
        ratio = ratioh;
        c.width = width * ratio;
      }
      ctx.scale(ratio, ratio);
      return world.render(canvas);
    };
  };

  gameloop = function(world, canvas) {
    world.update();
    return world.render(canvas);
  };

  clone = function(obj) {
    var flags, key, newInstance;
    if ((obj == null) || typeof obj !== 'object') {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (obj instanceof RegExp) {
      flags = '';
      if (obj.global != null) {
        flags += 'g';
      }
      if (obj.ignoreCase != null) {
        flags += 'i';
      }
      if (obj.multiline != null) {
        flags += 'm';
      }
      if (obj.sticky != null) {
        flags += 'y';
      }
      return new RegExp(obj.source, flags);
    }
    newInstance = new obj.constructor();
    for (key in obj) {
      newInstance[key] = clone(obj[key]);
    }
    return newInstance;
  };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.main = main;

}).call(this);

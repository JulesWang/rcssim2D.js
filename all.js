// Generated by CoffeeScript 1.6.3
var Ball, Canvas, KEY_DOWN, KEY_UP, K_0, K_1, K_2, K_3, K_4, K_5, K_6, K_7, K_8, K_9, K_ALT, K_BACKSPACE, K_CTRL, K_DOWN, K_ENTER, K_ESC, K_LEFT, K_RIGHT, K_SHIFT, K_SPACE, K_TAB, K_UP, K_a, K_b, K_c, K_d, K_e, K_f, K_g, K_h, K_i, K_j, K_k, K_l, K_m, K_n, K_o, K_p, K_q, K_r, K_s, K_t, K_u, K_v, K_w, K_x, K_y, K_z, MOUSE_DOWN, MOUSE_MOTION, MOUSE_UP, MOUSE_WHEEL, Pitch, Player, QUIT, Vector2d, WorldModel, gameloop, main, multiply, onkeydown, onmousedown;

K_UP = 38;

K_DOWN = 40;

K_RIGHT = 39;

K_LEFT = 37;

K_SPACE = 32;

K_BACKSPACE = 8;

K_TAB = 9;

K_ENTER = 13;

K_SHIFT = 16;

K_CTRL = 17;

K_ALT = 18;

K_ESC = 27;

K_0 = 48;

K_1 = 49;

K_2 = 50;

K_3 = 51;

K_4 = 52;

K_5 = 53;

K_6 = 54;

K_7 = 55;

K_8 = 56;

K_9 = 57;

K_a = 65;

K_b = 66;

K_c = 67;

K_d = 68;

K_e = 69;

K_f = 70;

K_g = 71;

K_h = 72;

K_i = 73;

K_j = 74;

K_k = 75;

K_l = 76;

K_m = 77;

K_n = 78;

K_o = 79;

K_p = 80;

K_q = 81;

K_r = 82;

K_s = 83;

K_t = 84;

K_u = 85;

K_v = 86;

K_w = 87;

K_x = 88;

K_y = 89;

K_z = 90;

QUIT = 0;

KEY_DOWN = 1;

KEY_UP = 2;

MOUSE_MOTION = 3;

MOUSE_UP = 4;

MOUSE_DOWN = 5;

MOUSE_WHEEL = 6;

onkeydown = function(ev, wm) {
  var obj;
  if (!wm.selected) {
    return;
  }
  obj = wm.selected;
  if (!obj.dash) {
    return;
  }
  switch (ev.keyCode) {
    case K_UP:
      return obj.dash(36);
    case K_DOWN:
      return obj.dash(-36);
    case K_LEFT:
      return obj.turn(1);
    case K_RIGHT:
      return obj.turn(-1);
    case K_d:
      return obj.kick(2);
  }
};

onmousedown = function(ev, wm, x, y) {
  var obj, _i, _len, _ref;
  _ref = wm.objs;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    obj = _ref[_i];
    if (obj.r === void 0 || obj.x === void 0 || obj.y === void 0) {
      continue;
    }
    if (Math.abs(x - obj.x) < obj.r && Math.abs(y - obj.y) < obj.r) {
      wm.selected = obj;
      obj.sc = "#87CEFA";
      return 1;
    }
  }
  return 0;
};

Player = (function() {
  function Player(x, y, dir) {
    this.fc = 'gray';
    this.sc = 'black';
    this.m = 60.0;
    this.r = 10;
    this.t = 'none';
    this.x = x;
    this.y = y;
    this.v = [0, 0];
    this.d = dir;
    this.decay = 0.4;
    this.MAXDASHFORCE = 36;
    this.MAXKICKFORCE = 36;
    this.MAXTURNANGLE = 0.1;
    this.force = 0;
    this.dd = 0;
  }

  Player.prototype.render = function(canvas) {
    var fillColor, strokeColor;
    strokeColor = this.sc;
    fillColor = this.fc;
    canvas.fillCircle(this.fc, this.x, this.y, this.r);
    canvas.drawCircle(this.sc, this.x, this.y, this.r);
    return canvas.fillArc(this.sc, this.x, this.y, this.r, this.d - 2 * Math.PI / 5, this.d + 2 * Math.PI / 5);
  };

  Player.prototype.update = function() {
    var a, ds, dv, unitv, _ref;
    if (Vector2d.len(this.v) > 1e-3) {
      ds = this.v;
      _ref = Vector2d.add([this.x, this.y], ds), this.x = _ref[0], this.y = _ref[1];
      this.v = Vector2d.multiply(this.v, this.decay);
    }
    a = this.force / this.m;
    this.force = 0;
    unitv = Vector2d.vector(this.d);
    dv = Vector2d.multiply(unitv, a);
    this.v = Vector2d.add(this.v, dv);
    this.d += this.dd;
    return this.dd = 0;
  };

  Player.prototype.dash = function(force) {
    if (force > this.MAXDASHFORCE) {
      force = this.MAXDASHFORCE;
    }
    if (force < -this.MAXDASHFORCE) {
      force = -this.MAXDASHFORCE;
    }
    return this.force = force;
  };

  Player.prototype.turn = function(dir) {
    this.dd = dir;
    if (this.dd > this.MAXTURNANGLE) {
      this.dd = this.MAXTURNANGLE;
    }
    if (this.dd < -this.MAXTURNANGLE) {
      return this.dd = -this.MAXTURNANGLE;
    }
  };

  Player.prototype.kick = function(force) {
    var p2b, unitv;
    if (!this.ball) {
      return;
    }
    if (Vector2d.distance([this.x, this.y], [this.ball.x, this.ball.y]) > 20) {
      return;
    }
    p2b = Vector2d.subtract([this.ball.x, this.ball.y], [this.x, this.y]);
    unitv = Vector2d.vector(this.d);
    if (Math.abs(Vector2d.angle(p2b, unitv)) > Math.PI / 6) {
      return;
    }
    if (force > this.MAXKICKFORCE) {
      force = this.MAXKICKFORCE;
    }
    return this.ball.acc(unitv, force);
  };

  return Player;

})();

Pitch = (function() {
  function Pitch() {
    this.pitch_length = 1050;
    this.pitch_width = 680;
    this.center_circle_r = 91.5;
    this.penalty_area_length = 165;
    this.penalty_area_width = 403.2;
    this.penalty_circle_r = 91.5;
    this.penalty_spot_dist = 110;
    this.goal_width = 140.2;
    this.goal_area_length = 55;
    this.goal_area_width = 183.2;
    this.goal_depth = 24.4;
    this.goal_post_radius = 0.6;
    this.corner_arc_r = 10;
    this.field_color = 'RGB(31, 160, 31)';
    this.line_color = 'RGB(255, 255, 255)';
    this.goal_color = '#000000';
  }

  Pitch.prototype.render = function(canvas) {
    var field, goal_area_bottom_y, goal_area_top_y, goal_area_x, goal_area_y_abs, goal_top_y, half_length, left_goal, left_x, pen_bottom_y, pen_circle_dia, pen_circle_r, pen_circle_y_degree_abs, pen_spot_x, pen_top_y, pen_x, post_bottom_y, post_diameter, post_top_y, right_goal, right_x;
    field = {
      x: -canvas.w / 2,
      y: -canvas.h / 2,
      w: canvas.w,
      h: canvas.h
    };
    canvas.fillRect(this.field_color, field);
    field = {
      x: -this.pitch_length / 2,
      y: -this.pitch_width / 2,
      w: this.pitch_length,
      h: this.pitch_width
    };
    canvas.drawRect(this.line_color, field);
    canvas.drawLine(this.line_color, 0, field.y, 0, field.y + field.h);
    canvas.drawArc(this.line_color, 0, 0, this.center_circle_r, 0, 2 * Math.PI);
    canvas.drawArc(this.line_color, field.x, field.y, this.corner_arc_r, 0, Math.PI / 2);
    canvas.drawArc(this.line_color, field.x + field.w, field.y, this.corner_arc_r, Math.PI / 2, Math.PI);
    canvas.drawArc(this.line_color, field.x + field.w, field.y + field.h, this.corner_arc_r, Math.PI, 3 * Math.PI / 2);
    canvas.drawArc(this.line_color, field.x, field.y + field.h, this.corner_arc_r, 3 * Math.PI / 2, 2 * Math.PI);
    half_length = this.pitch_length / 2;
    left_x = -half_length;
    right_x = half_length;
    pen_top_y = -this.penalty_area_width / 2;
    pen_bottom_y = this.penalty_area_width / 2;
    pen_circle_y_degree_abs = Math.acos((this.penalty_area_length - this.penalty_spot_dist) / this.penalty_circle_r);
    pen_circle_r = this.penalty_circle_r;
    pen_circle_dia = this.penalty_circle_r * 2.0;
    pen_x = -(half_length - this.penalty_area_length);
    pen_spot_x = -(half_length - this.penalty_spot_dist);
    canvas.drawArc(this.line_color, -(half_length + this.penalty_spot_dist - this.penalty_area_length), 0, pen_circle_dia, -pen_circle_y_degree_abs, pen_circle_y_degree_abs);
    canvas.drawLine(this.line_color, left_x, pen_top_y, pen_x, pen_top_y);
    canvas.drawLine(this.line_color, pen_x, pen_top_y, pen_x, pen_bottom_y);
    canvas.drawLine(this.line_color, pen_x, pen_bottom_y, left_x, pen_bottom_y);
    canvas.drawArc(this.line_color, pen_spot_x, 0, 1, 0, 2 * Math.PI);
    pen_x = +(half_length - this.penalty_area_length);
    pen_spot_x = +(half_length - this.penalty_spot_dist);
    canvas.drawArc(this.line_color, +(half_length + this.penalty_spot_dist - this.penalty_area_length), 0, pen_circle_dia, Math.PI - pen_circle_y_degree_abs, Math.PI + pen_circle_y_degree_abs);
    canvas.drawLine(this.line_color, right_x, pen_top_y, pen_x, pen_top_y);
    canvas.drawLine(this.line_color, pen_x, pen_top_y, pen_x, pen_bottom_y);
    canvas.drawLine(this.line_color, pen_x, pen_bottom_y, right_x, pen_bottom_y);
    canvas.drawArc(this.line_color, pen_spot_x, 0, 1, 0, 2 * Math.PI);
    left_x = -this.pitch_length / 2;
    right_x = +this.pitch_length / 2;
    goal_area_y_abs = this.goal_area_width / 2;
    goal_area_top_y = -goal_area_y_abs;
    goal_area_bottom_y = +goal_area_y_abs;
    goal_area_x = left_x + this.goal_area_length;
    canvas.drawLine(this.line_color, left_x, goal_area_top_y, goal_area_x, goal_area_top_y);
    canvas.drawLine(this.line_color, goal_area_x, goal_area_top_y, goal_area_x, goal_area_bottom_y);
    canvas.drawLine(this.line_color, goal_area_x, goal_area_bottom_y, left_x, goal_area_bottom_y);
    goal_area_x = right_x - this.goal_area_length;
    canvas.drawLine(this.line_color, right_x, goal_area_top_y, goal_area_x, goal_area_top_y);
    canvas.drawLine(this.line_color, goal_area_x, goal_area_top_y, goal_area_x, goal_area_bottom_y);
    canvas.drawLine(this.line_color, goal_area_x, goal_area_bottom_y, right_x, goal_area_bottom_y);
    goal_top_y = -this.goal_width * 0.5;
    post_top_y = -this.goal_width * 0.5 - this.goal_post_radius * 2.0;
    post_bottom_y = this.goal_width * 0.5;
    post_diameter = this.goal_post_radius * 2.0;
    left_goal = {
      x: -this.pitch_length / 2 - this.goal_depth - 1,
      y: goal_top_y,
      w: this.goal_depth,
      h: this.goal_width
    };
    canvas.fillRect(this.goal_color, left_goal);
    right_goal = {
      x: this.pitch_length / 2 + 1,
      y: goal_top_y,
      w: this.goal_depth,
      h: this.goal_width
    };
    return canvas.fillRect(this.goal_color, right_goal);
  };

  return Pitch;

})();

Ball = (function() {
  function Ball(x, y) {
    this.r = 4;
    this.m = 0.2;
    this.sc = "#FFA500";
    this.fc = "#FFA500";
    this.x = x;
    this.y = y;
    this.v = [0, 0];
    this.decay = 0.94;
  }

  Ball.prototype.acc = function(dir, force) {
    var a, dv, unitdir;
    unitdir = Vector2d.unit(dir);
    a = Vector2d.multiply(unitdir, force / this.m);
    dv = a;
    this.v = Vector2d.add(this.v, dv);
    return console.log(this.v);
  };

  Ball.prototype.render = function(canvas) {
    canvas.drawCircle(this.sc, this.x, this.y, this.r + 1);
    return canvas.fillCircle(this.fc, this.x, this.y, this.r);
  };

  Ball.prototype.update = function() {
    var ds, _ref;
    if (Vector2d.len(this.v) > 1e-3) {
      ds = this.v;
      _ref = Vector2d.add([this.x, this.y], ds), this.x = _ref[0], this.y = _ref[1];
      return this.v = Vector2d.multiply(this.v, this.decay);
    }
  };

  return Ball;

})();

Canvas = function(ctx, w, h) {
  this.ctx = ctx;
  this.w = w;
  return this.h = h;
};

Canvas.prototype.fillRect = function(color, rect) {
  this.ctx.fillStyle = color;
  return this.ctx.fillRect(this.xscreen(rect.x), this.yscreen(rect.y), rect.w, rect.h);
};

Canvas.prototype.drawRect = function(color, rect) {
  this.ctx.strokeStyle = color;
  return this.ctx.strokeRect(this.xscreen(rect.x), this.yscreen(rect.y), rect.w, rect.h);
};

Canvas.prototype.drawLine = function(color, sx, sy, ex, ey) {
  this.ctx.strokeStyle = color;
  this.ctx.beginPath();
  this.ctx.moveTo(this.xscreen(sx), this.yscreen(sy));
  this.ctx.lineTo(this.xscreen(ex), this.yscreen(ey));
  return this.ctx.stroke();
};

Canvas.prototype.drawArc = function(color, x, y, r, sAngle, eAngle) {
  this.ctx.strokeStyle = color;
  this.ctx.beginPath();
  this.ctx.arc(this.xscreen(x), this.yscreen(y), r, sAngle, eAngle);
  return this.ctx.stroke();
};

Canvas.prototype.fillArc = function(color, x, y, r, sAngle, eAngle) {
  this.ctx.fillStyle = color;
  this.ctx.beginPath();
  this.ctx.arc(this.xscreen(x), this.yscreen(y), r, sAngle, eAngle);
  return this.ctx.fill();
};

Canvas.prototype.drawCircle = function(color, x, y, r) {
  return this.drawArc(color, x, y, r, 0, 2 * Math.PI);
};

Canvas.prototype.fillCircle = function(color, x, y, r) {
  return this.fillArc(color, x, y, r, 0, 2 * Math.PI);
};

Canvas.prototype.drawText = function(color, font, text, x, y) {
  this.ctx.fillStyle = color;
  this.ctx.font = font;
  x = x - this.ctx.measureText(text).width / 2;
  return this.ctx.fillText(text, this.xscreen(x), this.yscreen(y));
};

Canvas.prototype.xscreen = function(x) {
  return x + this.w / 2;
};

Canvas.prototype.yscreen = function(y) {
  return y + this.h / 2;
};

WorldModel = (function() {
  function WorldModel() {
    this.objs = [];
  }

  WorldModel.prototype.register = function(obj) {
    return this.objs.push(obj);
  };

  WorldModel.prototype.unregister = function(obj) {
    var idx;
    idx = this.objs.indexOf(obj);
    if (idx >= 0) {
      return this.objs.splice(idx, 1);
    }
  };

  WorldModel.prototype.render = function(canvas) {
    var obj, _i, _len, _ref, _results;
    _ref = this.objs;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      obj = _ref[_i];
      if (obj.render) {
        _results.push(obj.render(canvas));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  WorldModel.prototype.update = function() {
    var obj, _i, _len, _ref, _results;
    _ref = this.objs;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      obj = _ref[_i];
      if (obj.update) {
        _results.push(obj.update());
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  return WorldModel;

})();

Vector2d = {};

Vector2d.distance = function(a, b) {
  return Vector2d.len(Vector2d.subtract(a, b));
};

Vector2d.subtract = function(a, b) {
  return [a[0] - b[0], a[1] - b[1]];
};

Vector2d.add = function(a, b) {
  return [a[0] + b[0], a[1] + b[1]];
};

Vector2d.multiply = multiply = function(a, s) {
  if (typeof s === 'number') {
    return [a[0] * s, a[1] * s];
  }
  return [a[0] * s[0], a[1] * s[1]];
};

Vector2d.divide = function(a, s) {
  if (typeof s === 'number') {
    return [a[0] / s, a[1] / s];
  }
  throw new Error('only divide by scalar supported');
};

Vector2d.len = function(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
};

Vector2d.unit = function(v) {
  var len;
  len = Vector2d.len(v);
  if (len) {
    return [v[0] / len, v[1] / len];
  }
  return [0, 0];
};

Vector2d.rotate = function(v, angle) {
  angle = math.normaliseRadians(angle);
  return [v[0] * Math.cos(angle) - v[1] * Math.sin(angle), v[0] * Math.sin(angle) + v[1] * Math.cos(angle)];
};

Vector2d.dot = function(v1, v2) {
  return (v1[0] * v2[0]) + (v1[1] * v2[1]);
};

Vector2d.angle = function(v1, v2) {
  var perpDot;
  perpDot = v1[0] * v2[1] - v1[1] * v2[0];
  return Math.atan2(perpDot, Vector2d.dot(v1, v2));
};

Vector2d.truncate = function(v, maxLength) {
  if (Vector2d.len(v) > maxLength) {
    return multiply(Vector2d.unit(v), maxLength);
  }
  return v;
};

Vector2d.vector = function(angle) {
  return [Math.cos(angle), Math.sin(angle)];
};

Math.normaliseDegrees = function(degrees) {
  degrees = degrees % 360;
  if (degrees < 0) {
    degrees += 360;
  }
  return degrees;
};

Math.normaliseRadians = function(radians) {
  radians = radians % (2 * Math.PI);
  if (radians < 0) {
    radians += 2 * Math.PI;
  }
  return radians;
};

Math.degrees = function(radians) {
  return radians * (180 / Math.PI);
};

Math.radians = function(degrees) {
  return degrees * (Math.PI / 180);
};

main = function() {
  var ball, c, canvas, ctx, height, offsetX, offsetY, pitch, player, width, world;
  c = document.getElementById("myCanvas");
  ctx = c.getContext("2d");
  width = c.width;
  height = c.height;
  offsetX = c.offsetLeft;
  offsetY = c.offsetTop;
  canvas = new Canvas(ctx, width, height);
  world = new WorldModel();
  pitch = new Pitch();
  world.register(pitch);
  ball = new Ball(0, 0);
  world.register(ball);
  player = new Player(20, 0, 0);
  player.ball = ball;
  world.register(player);
  document.addEventListener('mousedown', function(ev) {
    var x, y;
    if (ev.offsetX === void 0) {
      x = ev.pageX - offsetX - width / 2;
      y = ev.pageY - offsetY - height / 2;
    } else {
      x = ev.offsetX - width / 2;
      y = ev.offsetY - height / 2;
    }
    return onmousedown(ev, world, x, y);
  }, false);
  document.addEventListener('keydown', function(ev) {
    return onkeydown(ev, world);
  }, false);
  return setInterval(function() {
    return gameloop(world, canvas);
  }, 10);
};

gameloop = function(world, canvas) {
  world.update();
  return world.render(canvas);
};
